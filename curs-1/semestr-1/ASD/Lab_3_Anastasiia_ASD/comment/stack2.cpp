#include <stdlib.h>
#include <iostream>
// Используем стандартные библиотеки

// Функция возвращает указатель на переменную типа int
int* stackMemory1()
{
    // объявляем локальную переменную а и задаем ей значение 1
    int a = 1;
    // возвращаем адрес этой переменной
    return &a;
}

// То же самое делаем с переменной b во второй функцииы
int* stackMemory2()
{
    int b = 2;
    return &b;
}

int main()
{
    // указатель содержит адрес локальной переменной из первой функции
    int* b = stackMemory1();
    // присваеваем переменной а1 значение по адресу, содержащемся в переменной б. 
    // Это значение локальной переменной из первой функции 1
    int a1 = *b; // 1
    // присуждаем переменной с адрес локальной переменной из второй функции
    int* c = stackMemory2();
    // присваеваем переменной а2 значение по адресу, содержащемся в переменной с. 
    // Это значение локальной переменной из второй функции 2
    int a2 = *c; // 2
    // У меня не компилируется эта программа, поэтому не могу проверить, но предположительно дело в том,
    // что указатели b и с указывают на локальные переменные, которые находятся в стеке.
    // После вызова второй функции, элемент на вершине стека будет иметь значение 2, но тот же адрес в памяти
    // Поэтому оба указателя будут указывать на один элемент.
    int a3 = *b; // 2

    // Вывести значения переменных на экран
    std::cout << a1 << std::endl; // prints 1
    std::cout << a2 << std::endl; // prints 2
    std::cout << a3 << std::endl; // prints 2
    std::cout << ((std::byte*) b - (std::byte*) c) << std::endl; // prints 0, pointers are equal

    return 0;
}